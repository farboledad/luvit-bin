/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */
//SNMP includes
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
//C includes
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
//CG includes
#include <libcg/cg_general.h>
#include <libcg/cg_wwan.h>
#include <libcg/cg_net.h>
//Defines
//#define DEV_NAME "usb0"
#define SIZEFOO 4096
#define SIZETIME 200
#define CS_REG 0
#define PS_REG 1
#define PIN 0
#define PIN_COUNT 1
#define PUK_COUNT 2
#define TIME 0
#define UPTIME 1
#define SYSLOAD1 2
#define SYSLOAD5 3
#define SYSLOAD15 4
#define CLIENTS 0
#define CONNECTS 1
#define LEAVES 2
#define die(e) do { fprintf(stderr, e); exit(EXIT_FAILURE); } while (0);

//SNMP .H includes
#include "cloudGatePrivate.h"

//For lac and cellid
#include <fcntl.h>
#include <termios.h>
#define NELEMS(x)  (sizeof(x) / sizeof(x[0]))
#define SERDEV "/dev/ttyUSB1"
#define BAUD B115200
#define SIZEBUFF 254

const char *mode_descr[] = { "CDMA", "UMTS" };
const char *int_status_descr[] = { "Disconnected", "Disconnected", "Connecting", "Connected", "On demand" };
const char *reg_status_descr[] = {"Not registered", "Registered", "Searching", "Registration Denied" , "Not used - error", "Registered-Roaming" };
const char *pin_status_descr[] = { "Unknown", "Not inserted", "Ready", "PIN needed", "PUK needed", "Failure", "Locked", "Not supported"};

char *wwan_device;
//const char *wlan_device;

typedef struct {
	int ok;
	char * status;
	const char * serviceType;
	const char * carrier;
	const char * mcc;
	const char * mnc;
	const char * rssi;
	const char * ecio;
	const char * rfChannel;
	const char * bandClass;
}s_diag;

typedef struct {
	char * cs_lac;
	char * cs_cellId;
	char * ps_lac;
	char * ps_cellId;
}s_cellInfo;

typedef struct {
	char * ip;
	char * bCast;
	char * nMask;
}s_ipConfig;

typedef struct
{
	char * rxPackets;
	char * rxBytes;
	char * txPackets;
	char * txBytes;
}s_dcounter;


void cgInit(char * name)
{
	int32_t level;
	cg_init(name);
	cg_get_api_level(&level);
	printf("%s\nAPI level: %d\n", name,level);

}

void cgDeInit(void)
{
	cg_deinit();
}

u_char * getSNR (void)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getSNR","called\n"));
	cg_status_t cg_status;
	char *serial_number;
	//Serial Number
	cg_status = cg_get_serial_number(&serial_number);
	switch (cg_status) {
		case CG_STATUS_OK:
			if (*serial_number) {
				return  serial_number;
			} else {
				return "Empty";
			}
			break;
		case CG_STATUS_ERROR:
			return "Generic error";
			break;
		case CG_STATUS_INVALID_PARAMETER:
			return "Invalid parameter";
			break;
		default:
			return "Unknown error";
			break;
	}
}

u_char * getIMEI (void)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getIMEI","called\n"));
	cg_status_t cg_status;
	char *imei;
	//IMEI
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );

	cg_status = cg_wwan_get_imei(wwan_device,&imei);
	switch (cg_status) {
		case CG_STATUS_OK:
			if (*imei) {
				return imei;
			} else {
				return "Empty";
			}
			break;
		case CG_STATUS_ERROR:
			return "Generic error";
			break;
		case CG_STATUS_INVALID_PARAMETER:
			return "Invalid parameter";
			break;
		default:
			return "Unknown error";
			break;
	}
}

u_char * getIMSI (void)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getIMSI","called\n"));
	cg_status_t cg_status;
	char *imsi;
	//IMSI
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_get_imsi(wwan_device,&imsi);
	switch (cg_status) {
		case CG_STATUS_OK:
			if (*imsi) {
				return imsi;
			} else {
				return "Empty";
			}
			break;
		case CG_STATUS_ERROR:
			return "Generic error";
			break;
		case CG_STATUS_INVALID_PARAMETER:
			return "Invalid parameter";
			break;
		default:
			return "Unknown error";
			break;
	}
}

const u_char * getIntStatus (void)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getIntStatus","called\n"));
	cg_status_t cg_status;
	cg_net_internet_status_t int_status;
	const char * result;
	//Internet status
	cg_status = cg_net_get_internet_status(&int_status);
	switch(cg_status)
	{
		case CG_STATUS_OK:
			result = int_status_descr[(int) int_status];
			DEBUGMSGTL(("verbose:cloudGatePrivate:getIntStatus","RESULT: %s\n",result));
			return result;
			break;
		case CG_STATUS_ERROR:
			return "Error";
			break;
		default:
			return "Invalid parameter";
			break;
	}	
}

typedef enum {
	CGAGENT_WWAN_CARRIER = 0,
	CGAGENT_WWAN_SERVICE_TYPE,
	CGAGENT_WWAN_PLMN,
} cgagent_wwan_req_type_t;

const u_char * decodeServiceType(cg_wwan_system_t t) {
	if (t & CG_SYS_NONE)
		return "none";
	else if (t & CG_SYS_GSM)
		return "GSM";
	else if (t & CG_SYS_GPRS)
		return "GPRS";
	else if (t & CG_SYS_EDGE)
		return "EDGE";
	else if (t & CG_SYS_WCDMA)
		return "WCDMA";
	else if (t & CG_SYS_HSDPA)
		return "HSDPA";
	else if (t & CG_SYS_HSUPA)
		return "HSUPA";
	else if (t & CG_SYS_HSPA)
		return "HSPA";
	else if (t & CG_SYS_HSDPAPLUS)
		return "HSDPAPLUS";
	else if (t & CG_SYS_HSPAPLUS)
		return "HSPAPLUS";
	else if (t & CG_SYS_LTE)
		return "LTE";
	else if (t & CG_SYS_CDMA)
		return "CDMA";
	else if (t & CG_SYS_EVDO)
		return "EVDO";
	else if (t & CG_SYS_EVDOREL0)
		return "EVDO rel 0";
	else if (t & CG_SYS_EVDOREVA)
		return "EVDO rel A";
	else
		return "unknown";
}

void getNetParameter(cgagent_wwan_req_type_t reqt, netsnmp_request_info *requests)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getNetParameter","called\n"));	
	cg_status_t cg_status;
	uint8_t automatic;
	cg_wwan_network_t network;

	//Registration status
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_get_nw_selection_mode(wwan_device, &automatic, &network);
	DEBUGMSGTL(("verbose:cloudGatePrivate:getNetParameter","cg_wwan_get_nw_selection_mode status: %d\n",cg_status));
	const char * res = NULL;
	char buf[10];
    switch(cg_status) {
		case CG_STATUS_OK:
			switch (reqt) {
				case CGAGENT_WWAN_CARRIER:
					res = network.name;
	                break;
				case CGAGENT_WWAN_SERVICE_TYPE:
					res = decodeServiceType(network.system_type);
					break;
				case CGAGENT_WWAN_PLMN:
					snprintf(buf, 10, "%d", network.id);
					res = buf;
					break;
				default:
					res = "Strange request";
					break;
			}
			break;
		case CG_STATUS_ERROR:
			res = "General error";
			break;
		case CG_STATUS_INVALID_PARAMETER:
			res = "Invalid parameter";
			break;
		case CG_STATUS_RESOURCE_BUSY:
		default:
			res = "Unknown error";
			break;
    }
	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, res, strlen(res));
}

typedef enum {
	CGAGENT_SIG_RSSI = 0,
	CGAGENT_SIG_ECIO,
} cgagent_sig_req_type_t;

void getSig(cgagent_sig_req_type_t reqt, netsnmp_request_info *requests)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getSig","called\n"));	
	cg_status_t cg_status;
	int8_t rssi, ecio;

	const char * result;
	//Registration status
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_signal_strength(wwan_device, &rssi, &ecio);
	DEBUGMSGTL(("verbose:cloudGatePrivate:getSig","cg_wwan_signal_strength status: %d\n",cg_status));
	const char * res = NULL;
	char buf[10];
    switch(cg_status) {
		case CG_STATUS_OK:
			switch (reqt) {
				case CGAGENT_SIG_RSSI:
					snprintf(buf, 10, "%hhd", rssi);
					res = buf;
					break;
				case CGAGENT_SIG_ECIO:
					snprintf(buf, 10, "%hhd", ecio);
					res = buf;
					break;
				default:
					res = "Strange request";
					break;
			}
			break;
		case CG_STATUS_ERROR:
			res = "General error";
			break;
		case CG_STATUS_INVALID_PARAMETER:
			res = "Invalid parameter";
			break;
		case CG_STATUS_RESOURCE_BUSY:
		default:
			res = "Unknown error";
			break;
    }
	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, res, strlen(res));
}

const u_char * getRegStatus (int reg)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getRegStatus","called\n"));	
	cg_status_t cg_status;
	cg_wwan_reg_state_t reg_state;
	const char * result;
	//Registration status
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_get_reg_state(wwan_device, &reg_state);
	DEBUGMSGTL(("verbose:cloudGatePrivate:getRegStatus","REG REQUEST status: %d ps: %d cs: %d\n",cg_status,reg_state.ps_state,reg_state.cs_state));
    switch(cg_status) {
		case CG_STATUS_OK:
			if(reg == CS_REG)
			{
				result = reg_status_descr[reg_state.cs_state];
				DEBUGMSGTL(("verbose:cloudGatePrivate:getRegStatus","REG REQUEST: %d and RESULT: %s\n",reg,result));
				return result;
			}
			else
			{
				result = reg_status_descr[reg_state.ps_state];
				DEBUGMSGTL(("verbose:cloudGatePrivate:getRegStatus","REG REQUEST: %d and RESULT: %s\n",reg,result));
				return result;
			}
			break;
		case CG_STATUS_ERROR:
			return "Error getting reg state";
			break;
		case CG_STATUS_INVALID_PARAMETER:
			return "Invalid parameter";
			break;
		case CG_STATUS_RESOURCE_BUSY:
		default:
			return "Unknown error";
			break;
    }
}

u_char * getPinState(int pin)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getPinState","called\n"));
	cg_status_t cg_status;
	cg_wwan_pin_state_t pin_state;
	char * result;
	//char result_count[5];
	//PIN STATE
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_pin_get_state(wwan_device, &pin_state);
	switch(cg_status) {
		case CG_STATUS_OK:
			if(pin == PIN)
			{
				result = strdup(pin_status_descr[pin_state.pin_type]);
				DEBUGMSGTL(("verbose:cloudGatePrivate:getPinState","REQUEST: %d RESULT: %s\n",pin,result));
				return result;
			}
			else if(pin == PIN_COUNT)
			{
				asprintf(&result,"%d",pin_state.pin_retries);
				DEBUGMSGTL(("verbose:cloudGatePrivate:getPinState","REQUEST: %d RESULT: %s\n",pin,result));
				return result;
			}
			else if(pin == PUK_COUNT)
			{
				asprintf(&result,"%d",pin_state.puk_retries);
				DEBUGMSGTL(("verbose:cloudGatePrivate:getPinState","REQUEST: %d RESULT: %s\n",pin,result));
				return result;
			}
			break;
		case CG_STATUS_ERROR:
			result = strdup("Error getting pin state");
			return result;
			break;
		case CG_STATUS_INVALID_PARAMETER:
			result = strdup("Invalid parameter");
			return result;
			break;
		default:
			result = strdup("Unknown error");
			return result;
			break;
	}
}

s_diag getDiagnostics (void)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","called\n"));
	cg_status_t cg_status;
	cg_wwan_diag_param_t *params;
	uint32_t num_params=0;
	int count;
	s_diag diagnostics = {1,"","","","","","","","",""};
	//Diagnostics
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_get_diagnostics(wwan_device, &num_params, &params);
	switch (cg_status) {
		case CG_STATUS_OK:
			diagnostics.ok=0;
			diagnostics.status="OK";
			for (count = 0; count < num_params; count++)
			{
				if(strcmp(params[count].name,"Service Type")==0)
				{
					diagnostics.serviceType=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.serviceType));
				}
				else if(strcmp(params[count].name,"Carrier")==0)
				{
					diagnostics.carrier=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.carrier));
				}
				else if(strcmp(params[count].name,"MCC")==0)
				{
					diagnostics.mcc=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.mcc));
				}
				else if(strcmp(params[count].name,"MNC")==0)
				{
					diagnostics.mnc=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.mnc));
				}
				else if(strcmp(params[count].name,"RSSI")==0)
				{
					diagnostics.rssi=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.rssi));
				}
				else if(strcmp(params[count].name,"ECIO")==0)
				{
					diagnostics.ecio=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.ecio));
				}
				else if(strcmp(params[count].name,"RF channel")==0)
				{
					diagnostics.rfChannel=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.rfChannel));
				}
				else if(strcmp(params[count].name,"Band class")==0)
				{
					diagnostics.bandClass=params[count].value;
					DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Param. Value %s\n",diagnostics.bandClass));
				}

			}
			return diagnostics;
			break;
		case CG_STATUS_ERROR:
			DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Gen. Error\n"));
			diagnostics.status="Generic error";
			return diagnostics;
			break;
		case CG_STATUS_INVALID_PARAMETER:
			DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Inv. Parameter\n"));
			diagnostics.status="Invalid parameter";
			return diagnostics;
			break;
		default:
			DEBUGMSGTL(("verbose:cloudGatePrivate:getDiagnostics","Unk. Error\n"));
			diagnostics.status="Unknown error";
			return diagnostics;
			break;
	}
}

s_cellInfo getLacAndCellId(int opt)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getLacAndCellId","called\n"));
	s_cellInfo result={"","","",""};
	char *str = (char*) calloc (SIZEBUFF,sizeof(char));
	struct termios tio;
	struct termios stdio;
	struct termios old_stdio;
	int tty_fd;

	char buff[SIZEBUFF];
	char lcid[2][10];
	char *commands[3];
	memset(buff,0,SIZEBUFF);
	memset(lcid,0,sizeof(lcid));

	if(opt == CS_REG)
	{
		commands[0]="at+creg=2\r\n";
		commands[1]="at+creg?\r\n";
		commands[2]="at+creg\r\n";
	}
	else
	{
		commands[0]="at+cgreg=2\r\n";
		commands[1]="at+cgreg?\r\n";
		commands[2]="at+cgreg\r\n";
	}
	
	int numcommands = NELEMS(commands);
	
	tcgetattr(STDOUT_FILENO,&old_stdio);

	memset(&stdio,0,sizeof(stdio));
	stdio.c_iflag=0;
	stdio.c_oflag=0;
	stdio.c_cflag=0;
	stdio.c_lflag=0;
	stdio.c_cc[VMIN]=1;
	stdio.c_cc[VTIME]=0;
	tcsetattr(STDOUT_FILENO,TCSANOW,&stdio);
	tcsetattr(STDOUT_FILENO,TCSAFLUSH,&stdio);
	fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);       // make the reads non-blocking

	memset(&tio,0,sizeof(tio));
	tio.c_iflag=0;
	tio.c_oflag=0;
	tio.c_cflag=CS8|CREAD|CLOCAL;           // 8n1, see termios.h for more information
	tio.c_lflag=0;
	tio.c_cc[VMIN]=1;
	tio.c_cc[VTIME]=5;

	tty_fd=open(SERDEV, O_RDWR | O_NONBLOCK);
	cfsetospeed(&tio,BAUD);            // 115200 baud
	cfsetispeed(&tio,BAUD);            // 115200 baud

	tcsetattr(tty_fd,TCSANOW,&tio);
	int i;
	for (i=0;i<numcommands;i++)
	{
		write(tty_fd,commands[i],strlen(commands[i])); // if new data is available on the console, send it to the serial port
		sleep(1);

		if (read(tty_fd,buff,SIZEBUFF)>0)
		{
			if(strchr(buff,':')!=NULL)
			{
				DEBUGMSGTL(("verbose:cloudGatePrivate:getLacAndCellId","Correct answer: %s\n",buff));
				str=strtok(buff,", \r");
				int i=0;
				while(str!=NULL)
				{
					switch(i)
					{
						case 4: 
							if(opt==CS_REG)
							{
								result.cs_lac=str;
								DEBUGMSGTL(("verbose:cloudGatePrivate:getLacAndCellId","CS_LAC answer: %s\n",result.cs_lac));
							}
							else
							{
								result.ps_lac=str;
								DEBUGMSGTL(("verbose:cloudGatePrivate:getLacAndCellId","PS_LAC answer: %s\n",result.ps_lac));
							}
							break;
						case 5: 
							if(opt==CS_REG)
							{
								result.cs_cellId=str;
								DEBUGMSGTL(("verbose:cloudGatePrivate:getLacAndCellId","CS_CellID answer: %s\n",result.cs_cellId));
							}
							else
							{
								result.ps_cellId=str;
								DEBUGMSGTL(("verbose:cloudGatePrivate:getLacAndCellId","PS_CellID answer: %s\n",result.ps_cellId));
							}
							break;
						default:
							break;
					}
					str=strtok(NULL," ,\r");
					i++;
				}		
			}
		}
	}
	free(str);
	close(tty_fd);
	tcsetattr(STDOUT_FILENO,TCSANOW,&old_stdio);
	return result;
}

void delChar(char *str,char ch)
{
	char *pr = str, *pw = str;
	while(*pr){
		*pw = *pr++;
		pw += (*pw != ch);
	}
	*pw = '\0';
}

void getHostName(char * hostname)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getHostName","called\n"));
	char * foo = hostname;
	pid_t pid;
	int fd[2];
	int i;
	//HOSTNAME
	if (pipe(fd)==-1) die("pipe");
	pid=fork();
	if (pid ==-1) die("fork");

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("cat /etc/config/system|grep hostname|tr -s ' '|cut -d ' ' -f 3");
		_exit(0);
	}else{
		close(fd[1]);
		read(fd[0], foo, SIZEFOO);
		DEBUGMSGTL(("verbose:cloudGatePrivate:getHostName","Hostname 1: %s\n",foo));
		delChar(foo,'\'');
		DEBUGMSGTL(("verbose:cloudGatePrivate:getHostName","Hostname 2: %s\n",foo));
		close(fd[0]);
		waitpid(pid, &i, 0);
	}
}

unsigned int getClients (int opt)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getClients","called\n"));
	char * foo;
	char * next;
	pid_t pid;
	int fd[2];
	int i;
	unsigned int result=0;

	if (pipe(fd)==-1)die("pipe");
	pid=fork();
	if (pid ==-1)die("fork");

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("cat /sys/kernel/redpine-rs9110/associations");
		_exit(0);
	}else{
		close(fd[1]);
		foo = (char*) calloc (SIZEFOO, sizeof(char));
		read(fd[0], foo, SIZEFOO);
		next=strtok(foo,",");
		i=0;
		while(next != NULL)
		{
			switch(i)
			{
				case 0:
					if(opt == CLIENTS)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getClients","Clients: %s\n",next));
						result = atoi(next);
					}
					break;
				case 1:
					if(opt == CONNECTS)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getClients","Connects: %s\n",next));
						result = atoi(next);
					}
					break;
				case 2:
					if(opt == LEAVES)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getClients","Disconnects: %s\n",next));
						result = atoi(next);
					}
					break;
				default:
					break;
			}
			next=strtok(NULL,",");
			i++;
		}
		free(foo);
		close(fd[0]);
		waitpid(pid, &i, 0);
	}
	return result;
}

char * getESSID ()
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getESSID","called\n"));
	char * essid;
	int broadcast;

	cg_wlan_ap_get_ssid ( "uap0", &essid, &broadcast);
	return essid;
}

char * getWlanMac ()
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getWlanMac","called\n"));
	char * mac;
	pid_t pid;
	int fd[2];
	int i;

	if (pipe(fd)==-1)
	die("pipe");
	pid=fork();
	if (pid ==-1){die("fork");}

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("ifconfig uap0 | grep HWaddr |  sed -n -e 's/^.*HWaddr //p'");
		_exit(0);
	}else{
		close(fd[1]);
		mac = malloc (SIZEFOO);
		read(fd[0], mac, SIZEFOO);
		mac[17]='\0';
		close(fd[0]);
		waitpid(pid, &i, 0);
		return mac;
	}
}

char * getWlanFreq ()
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getWlanFreq","called\n"));
	char * freq;
	pid_t pid;
	int fd[2];
	int i;
	char * ptr;

	if (pipe(fd)==-1)
	die("pipe");
	pid=fork();
	if (pid ==-1){die("fork");}

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("iwconfig uap0 | grep Frequency | sed -n -e 's/^.*Frequency://p' |sed -n -e 's/Hz.*$/Hz=/p'");
		_exit(0);
	}else{
		close(fd[1]);
		freq = malloc (SIZEFOO);
		read(fd[0], freq, SIZEFOO);
		ptr = freq;
		while ((*ptr != '=') && (*ptr != '\0')) ptr++;
		*ptr = '\0';
		close(fd[0]);
		waitpid(pid, &i, 0);
		return freq;
	}
}
int getWlanChan ()
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getWlanChan","called\n"));
//	int channel;
	uint16_t channel;

	cg_wlan_ap_get_channel ( "uap0", &channel);
	return (int) channel;
}



void getAPN (char * apn)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getAPN","called\n"));
/*	char * foo = apn;
	pid_t pid;
	int fd[2];
	int i;
*/
	cg_wwan_network_settings_t *wwan_network_settings;
	cg_status_t stat;

	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	stat = cg_wwan_get_network_settings(wwan_device, &wwan_network_settings);
	if (stat == CG_STATUS_OK) {
		strcpy(apn, wwan_network_settings->apn);
		free(wwan_network_settings);
	}
	else {
		strcpy(apn, "Error");
	}
/*
	//APN, USERNAME AND PASSWORD
	if (pipe(fd)==-1)
	die("pipe");
	pid=fork();
	if (pid ==-1){die("fork");}

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("cat /etc/config/mcmd|awk 'BEGIN{RS=ORS='\\n\\n';FS=OFS='\\n'}/cd_default/'|grep apn|sed 's/\\toption//'|sed 's/apn//'|tr -d ' '");
		_exit(0);
	}else{
		close(fd[1]);
		read(fd[0], foo, SIZEFOO);
		DEBUGMSGTL(("verbose:cloudGatePrivate:getAPN","APN 1: %s\n",foo));
		if(*foo)
		{
			delChar(foo,'\'');
			DEBUGMSGTL(("verbose:cloudGatePrivate:getAPN","APN 2: %s\n",foo));
		}
		close(fd[0]);
		waitpid(pid, &i, 0);
	}
*/
}

void getTimesAndLoad (char * time,int opt)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getTimesAndLoad","called\n"));
	char * foo;
	char * next;
	char * result = time;
	pid_t pid;
	int fd[2];
	int i;
	//TIME,UPTIME AND LOAD
	if (pipe(fd)==-1)die("pipe");
	pid=fork();
	if (pid ==-1)die("fork");

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("uptime|tr -d ' '|sed 's/up/,/'|sed 's/loadaverage://'|sed 's/user//'|sed 's/Î<8d>¾^M//'");
		_exit(0);
	}else{
		close(fd[1]);
		foo = (char*) calloc (SIZEFOO, sizeof(char));
		read(fd[0], foo, SIZEFOO);
		next=strtok(foo,",");
		i=0;
		while(next != NULL)
		{
			switch(i)
			{
				case 0:
					if(opt == TIME)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getTimesAndLoad","Time: %s\n",next));
						memcpy(result,next,strlen(next)+1);
					}
					break;
				case 1:
					if(opt == UPTIME)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getTimesAndLoad","UpTime: %s\n",next));
						memcpy(result,next,strlen(next)+1);
					}
					break;
				case 2:
					if(opt == SYSLOAD1)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getTimesAndLoad","System load 1 min: %s\n",next));
						memcpy(result,next,strlen(next)+1);
					}
					break;
				case 3:
					if(opt == SYSLOAD5)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getTimesAndLoad","System load 5 min: %s\n",next));
						memcpy(result,next,strlen(next)+1);
					}
					break;
				case 4:
					if(opt == SYSLOAD15)
					{
						DEBUGMSGTL(("verbose:cloudGatePrivate:getTimesAndLoad","System load 15 min: %s\n",next));
						memcpy(result,next,strlen(next)+1);
					}
					break;
				default:
					break;
			}
			next=strtok(NULL,",");
			i++;
		}
		free(foo);
		close(fd[0]);
		waitpid(pid, &i, 0);
	}
}

s_ipConfig getIPConfig (void)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getIPConfig","called\n"));
	s_ipConfig net = {"","",""};
	char * foo;
	pid_t pid;
	int fd[2];
	int i;
	char * buffer;
	//IPs
	if (pipe(fd)==-1) die("pipe");
	pid=fork();
	if (pid ==-1) die("fork");

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
		if (!strcmp(wwan_device, "hso0"))
		{
			asprintf (&buffer, "ifconfig %s|grep inet\\ addr|tr -d ' '|sed 's/inetaddr://'|sed 's/P-t-P:/,/'|sed 's/Mask:/,/'", wwan_device);
		}
		else
		{
			asprintf (&buffer, "ifconfig %s|grep inet\\ addr|tr -d ' '|sed 's/inetaddr://'|sed 's/Bcast:/,/'|sed 's/Mask:/,/'", wwan_device);
		}
		system(buffer);
		free(buffer);
		_exit(0);
	}else{
		close(fd[1]);
		foo = (char*) calloc (SIZEFOO,sizeof(char));
		read(fd[0], foo, SIZEFOO);
		foo=strtok(foo,",");
		i=0;
		while(foo != NULL)
		{
			switch(i)
			{
				case 0:
					DEBUGMSGTL(("verbose:cloudGatePrivate:getIPConfig","IP: %s\n",foo));
					net.ip=foo;
					break;
				case 1:
					DEBUGMSGTL(("verbose:cloudGatePrivate:getIPConfig","Broadcast: %s\n",foo));
					net.bCast=foo;
					break;
				case 2:
					delChar(foo,'\n');
					DEBUGMSGTL(("verbose:cloudGatePrivate:getIPConfig","Netmask: %s\n",foo));
					net.nMask=foo;
					break;
				default:
					break;
			}
			foo=strtok(NULL,",");
			i++;
		}
		free(foo);
		close(fd[0]);
		waitpid(pid, &i, 0);
		return net;
	}
}

void getFirmMode(char * firmware)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmMode","called\n"));
	const char * foo;
	char * result = firmware;
	cg_status_t cg_status;
	cg_wwan_mode_t mode;
	//Firmware Mode
	if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	cg_status = cg_wwan_get_mode(wwan_device, &mode);
	if(cg_status == CG_STATUS_OK ) 
	{
		DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmMode","Status: OK\n"));
		foo=mode_descr[(int) mode];
		memcpy(result,foo,strlen(foo)+1);
		DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmMode","Firmware Mode: %s\n",result));
	} else {
		DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmMode","Status: Failed\n"));
		foo="Failed";
		memcpy(result,foo,strlen(foo)+1);
		DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmMode","Firmware Mode: %s\n",result));
	}
}

void getFirmVer(char * firmware)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmVer","called\n"));
	char * foo = firmware;
	pid_t pid;
	int fd[2];
	int i;

	//FIRMWARE VERSION
	if (pipe(fd)==-1) die("pipe");
	pid=fork();
	if (pid ==-1) die("fork");

	if(pid==0){
		dup2(fd[1],1);
		close(fd[0]);close(fd[1]);
		system("cat /etc/gitinfo|grep m2m-|sed 's/m2m\\-//'|sed 's/\\.[^.]*$//'");
		_exit(0);
	}else{
		close(fd[1]);
		read(fd[0], foo, SIZEFOO);
		if(*foo)
		{
			delChar(foo,'\n');
			DEBUGMSGTL(("verbose:cloudGatePrivate:getFirmVer","Firmware version: %s\n",foo));
		}
		close(fd[0]);
		waitpid(pid, &i, 0);
	}
}

void getCounters (char * dev_name, s_dcounter * counter)
{
	DEBUGMSGTL(("verbose:cloudGatePrivate:getCounters","called\n"));
	cg_status_t cg_status;
	cg_net_stats_t stats;
	int enabled;
	s_dcounter * count = counter;

	cg_status = cg_net_datacounter_get_enabled(dev_name, &enabled);
	if (cg_status == CG_STATUS_OK)
	{
		DEBUGMSGTL(("verbose:cloudGatePrivate:getCounters","Data counters state for device %s: %d\n", dev_name, enabled));
		if(enabled == TRUE)
		{
			cg_status = cg_net_datacounter_get_stats(dev_name, &stats);
			if (cg_status == CG_STATUS_OK)
			{
				sprintf(count->rxPackets,"%llu",stats.rx_packets);
				sprintf(count->rxBytes,"%llu",stats.rx_bytes);
				sprintf(count->txPackets,"%llu",stats.tx_packets);
				sprintf(count->txBytes,"%llu",stats.tx_bytes);
				DEBUGMSGTL(("verbose:cloudGatePrivate:getCounters","RX_Packets: %s RX_Bytes: %s TX_Packets: %s TX_Bytes %s\n",count->rxPackets,count->rxBytes,count->txPackets,count->txBytes));
			}
			else
			{
				DEBUGMSGTL(("verbose:cloudGatePrivate:getCounters","Failed\n"));
			}
		}
		else
		{
			DEBUGMSGTL(("verbose:cloudGatePrivate:getCounters","Datacounters are not enabled for %s\n", dev_name));
		}
	}
}


/** Initializes the cloudGatePrivate module */
void
init_cloudGatePrivate(void)
{
	static oid upTime_oid[] = { 1,3,6,1,4,1,21415,0,0,0 };
	static oid hostName_oid[] = { 1,3,6,1,4,1,21415,0,0,1 };
	static oid currentTime_oid[] = { 1,3,6,1,4,1,21415,0,0,2 };
	static oid serialNumber_oid[] = { 1,3,6,1,4,1,21415,0,0,3 };
	static oid sysLoad1_oid[] = { 1,3,6,1,4,1,21415,0,0,4 };
	static oid sysLoad5_oid[] = { 1,3,6,1,4,1,21415,0,0,5 };
	static oid sysLoad15_oid[] = { 1,3,6,1,4,1,21415,0,0,6 };
	static oid firmVer_oid[] = { 1,3,6,1,4,1,21415,0,0,7 };
	static oid apn_oid[] = { 1,3,6,1,4,1,21415,0,1,0 };
	static oid internetStatus_oid[] = { 1,3,6,1,4,1,21415,0,1,1 };
	static oid ipAddress_oid[] = { 1,3,6,1,4,1,21415,0,1,2 };
	static oid bCastAddress_oid[] = { 1,3,6,1,4,1,21415,0,1,3 };
	static oid netMask_oid[] = { 1,3,6,1,4,1,21415,0,1,4 };
	static oid csRegistration_oid[] = { 1,3,6,1,4,1,21415,0,1,5 };
	static oid psRegistration_oid[] = { 1,3,6,1,4,1,21415,0,1,6 };
	static oid imei_oid[] = { 1,3,6,1,4,1,21415,0,1,7 };
	static oid imsi_oid[] = { 1,3,6,1,4,1,21415,0,1,8 };
	static oid firmMode_oid[] = { 1,3,6,1,4,1,21415,0,1,9 };
	static oid carrier_oid[] = { 1,3,6,1,4,1,21415,0,1,10 };
	static oid rssi_oid[] = { 1,3,6,1,4,1,21415,0,1,11 };
	static oid ecio_oid[] = { 1,3,6,1,4,1,21415,0,1,12 };
	static oid bandClass_oid[] = { 1,3,6,1,4,1,21415,0,1,13 };
	static oid serviceType_oid[] = { 1,3,6,1,4,1,21415,0,1,14 };
	static oid rfChannel_oid[] = { 1,3,6,1,4,1,21415,0,1,15 };
	static oid plmn_oid[] = { 1,3,6,1,4,1,21415,0,1,16 };
	static oid csCellIDandLac_oid[] = { 1,3,6,1,4,1,21415,0,1,18 };
	static oid psCellIDandLac_oid[] = { 1,3,6,1,4,1,21415,0,1,19 };
	static oid pinStatus_oid[] = { 1,3,6,1,4,1,21415,0,1,20 };
	static oid pinRetries_oid[] = { 1,3,6,1,4,1,21415,0,1,21 };
	static oid pukRetries_oid[] = { 1,3,6,1,4,1,21415,0,1,22 };
	static oid rxPackets_oid[] = { 1,3,6,1,4,1,21415,0,1,23 };
	static oid rxBytes_oid[] = { 1,3,6,1,4,1,21415,0,1,24 };
	static oid txPackets_oid[] = { 1,3,6,1,4,1,21415,0,1,25 };
	static oid txBytes_oid[] = { 1,3,6,1,4,1,21415,0,1,26 };
	static oid AssociatedClients_oid[] = { 1,3,6,1,4,1,21415,0,2,0 };
	static oid ClientAssociations_oid[] = { 1,3,6,1,4,1,21415,0,2,1 };
	static oid ClientDisassociations_oid[] = { 1,3,6,1,4,1,21415,0,2,2 };
	static oid essid_oid[] = { 1,3,6,1,4,1,21415,0,2,3 };
	static oid wlanMAC_oid[] = { 1,3,6,1,4,1,21415,0,2,4 };
	static oid wlanFreq_oid[] = { 1,3,6,1,4,1,21415,0,2,5 };
	static oid wlanChan_oid[] = { 1,3,6,1,4,1,21415,0,2,6 };

	DEBUGMSGTL(("cloudGatePrivate", "Initializing\n"));
	cgInit("MIBS");

	cg_wwan_get_active_primary_dev( &wwan_device );

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("upTime", handle_upTime,
                               upTime_oid, OID_LENGTH(upTime_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("hostName", handle_hostName,
                               hostName_oid, OID_LENGTH(hostName_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("currentTime", handle_currentTime,
                               currentTime_oid, OID_LENGTH(currentTime_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("serialNumber", handle_serialNumber,
                               serialNumber_oid, OID_LENGTH(serialNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sysLoad1", handle_sysLoad1,
                               sysLoad1_oid, OID_LENGTH(sysLoad1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sysLoad5", handle_sysLoad5,
                               sysLoad5_oid, OID_LENGTH(sysLoad5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("sysLoad15", handle_sysLoad15,
                               sysLoad15_oid, OID_LENGTH(sysLoad15_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("firmVer", handle_firmVer,
                               firmVer_oid, OID_LENGTH(firmVer_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("AssociatedClients", handle_AssociatedClients,
                               AssociatedClients_oid, OID_LENGTH(AssociatedClients_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ClientAssociations", handle_ClientAssociations,
                               ClientAssociations_oid, OID_LENGTH(ClientAssociations_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ClientDisassociations", handle_ClientDisassociations,
                               ClientDisassociations_oid, OID_LENGTH(ClientDisassociations_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ESSID", handle_essid,
                               essid_oid, OID_LENGTH(essid_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("MAC", handle_wlanMAC,
                               wlanMAC_oid, OID_LENGTH(wlanMAC_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Frequency", handle_wlanFreq,
                               wlanFreq_oid, OID_LENGTH(wlanFreq_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("Channel", handle_wlanChan,
                               wlanChan_oid, OID_LENGTH(wlanChan_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("apn", handle_apn,
                               apn_oid, OID_LENGTH(apn_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("internetStatus", handle_internetStatus,
                               internetStatus_oid, OID_LENGTH(internetStatus_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ipAddress", handle_ipAddress,
                               ipAddress_oid, OID_LENGTH(ipAddress_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("bCastAddress", handle_bCastAddress,
                               bCastAddress_oid, OID_LENGTH(bCastAddress_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("netMask", handle_netMask,
                               netMask_oid, OID_LENGTH(netMask_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
    
        netsnmp_create_handler_registration("csRegistration", handle_csRegistration,
                               csRegistration_oid, OID_LENGTH(csRegistration_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("psRegistration", handle_psRegistration,
                               psRegistration_oid, OID_LENGTH(psRegistration_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("imei", handle_imei,
                               imei_oid, OID_LENGTH(imei_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("imsi", handle_imsi,
                               imsi_oid, OID_LENGTH(imsi_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("firmMode", handle_firmMode,
                               firmMode_oid, OID_LENGTH(firmMode_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("carrier", handle_carrier,
                               carrier_oid, OID_LENGTH(carrier_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("rssi", handle_rssi,
                               rssi_oid, OID_LENGTH(rssi_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ecio", handle_ecio,
                               ecio_oid, OID_LENGTH(ecio_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("bandClass", handle_bandClass,
                               bandClass_oid, OID_LENGTH(bandClass_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("serviceType", handle_serviceType,
                               serviceType_oid, OID_LENGTH(serviceType_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("rfChannel", handle_rfChannel,
                               rfChannel_oid, OID_LENGTH(rfChannel_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("plmn", handle_plmn,
                               plmn_oid, OID_LENGTH(plmn_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("csCellIDandLac", handle_csCellIDandLac,
                               csCellIDandLac_oid, OID_LENGTH(csCellIDandLac_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("psCellIDandLac", handle_psCellIDandLac,
                               psCellIDandLac_oid, OID_LENGTH(psCellIDandLac_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("pinStatus", handle_pinStatus,
                               pinStatus_oid, OID_LENGTH(pinStatus_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("pinRetries", handle_pinRetries,
                               pinRetries_oid, OID_LENGTH(pinRetries_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("pukRetries", handle_pukRetries,
                               pukRetries_oid, OID_LENGTH(pukRetries_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("rxPackets", handle_rxPackets,
                               rxPackets_oid, OID_LENGTH(rxPackets_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("rxBytes", handle_rxBytes,
                               rxBytes_oid, OID_LENGTH(rxBytes_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("txPackets", handle_txPackets,
                               txPackets_oid, OID_LENGTH(txPackets_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("txBytes", handle_txBytes,
                               txBytes_oid, OID_LENGTH(txBytes_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_upTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            getTimesAndLoad(result,UPTIME);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_upTime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_hostName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            getHostName(result);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
	    free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hostName\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_currentTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {
        case MODE_GET:
            getTimesAndLoad(result,TIME);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_currentTime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

}
int
handle_serialNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    switch(reqinfo->mode) {

        case MODE_GET:
	    result = getSNR();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_serialNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_sysLoad1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {
        case MODE_GET:
            getTimesAndLoad(result,SYSLOAD1);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysLoad1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_sysLoad5(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {
        case MODE_GET:
            getTimesAndLoad(result,SYSLOAD5);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysLoad5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_sysLoad15(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {
        case MODE_GET:
            getTimesAndLoad(result,SYSLOAD15);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysLoad15\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_firmVer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            getFirmVer(result);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_firmVer\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_AssociatedClients(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
int result;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {

        case MODE_GET:
            result = getClients(CLIENTS);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) & result, sizeof(result));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_AssociatedClients\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_ClientAssociations(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
int result;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {

        case MODE_GET:
            result = getClients(CONNECTS);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) & result, sizeof(result));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ClientAssociations\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_ClientDisassociations(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
int result;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {

        case MODE_GET:
            result = getClients(LEAVES);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) & result, sizeof(result));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ClientDisassociations\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_essid(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * essid;
    switch(reqinfo->mode) {

        case MODE_GET:
	    	essid = getESSID();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,essid,strlen(essid));
			free(essid);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_essid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_wlanMAC(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * mac;
    switch(reqinfo->mode) {

        case MODE_GET:
	    	mac = getWlanMac();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,mac,strlen(mac));
			free (mac);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_essid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_wlanFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    switch(reqinfo->mode) {

        case MODE_GET:
	    result = getWlanFreq();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
			free(result);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_essid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_wlanChan(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    int result;
    switch(reqinfo->mode) {

        case MODE_GET:
	    result = getWlanChan();
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) & result, sizeof(result));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_essid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_apn(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            getAPN(result);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_apn\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_internetStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    const char * result;
    switch(reqinfo->mode) {
        case MODE_GET:
	    result = getIntStatus();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_internetStatus\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_ipAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    s_ipConfig net = {"","",""};
    switch(reqinfo->mode) {

        case MODE_GET:
            net = getIPConfig();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,net.ip,strlen(net.ip));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ipAddress\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_bCastAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    s_ipConfig net = {"","",""};
    switch(reqinfo->mode) {

        case MODE_GET:
            //net = getIPConfig();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,net.bCast,strlen(net.bCast));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_bCastAddress\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_netMask(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    s_ipConfig net = {"","",""};
    switch(reqinfo->mode) {

        case MODE_GET:
            net = getIPConfig();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,net.nMask,strlen(net.nMask));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_netMask\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_csRegistration(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    const char * result;
    switch(reqinfo->mode) {

        case MODE_GET:
		    result = getRegStatus(CS_REG);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_csRegistration\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

}
int
handle_psRegistration(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    const char * result;
    switch(reqinfo->mode) {
        case MODE_GET:
		    result = getRegStatus(PS_REG);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_psRegistration\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_imei(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    switch(reqinfo->mode) {

        case MODE_GET:
	    	result = getIMEI();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_imei\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_imsi(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    switch(reqinfo->mode) {

        case MODE_GET:
	    	result = getIMSI();
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_imsi\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_firmMode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    result  = (char*) calloc (SIZEFOO,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            getFirmMode(result);
	   		DEBUGMSGTL(("verbose:cloudGatePrivate:handle_firmMode","Firmware Mode: %s\n",result));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_firmMode\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_carrier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {
        case MODE_GET:
        	getNetParameter(CGAGENT_WWAN_CARRIER, requests);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_carrier\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_rssi(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
static long rssi;

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {
        case MODE_GET:
			getSig(CGAGENT_SIG_RSSI, requests);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rssi\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_ecio(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {
        case MODE_GET:
			getSig(CGAGENT_SIG_ECIO, requests);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ecio\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_bandClass(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    s_diag diag = {1,"","","","","","","","",""};
    switch(reqinfo->mode) {
        case MODE_GET:
            diag = getDiagnostics();
            if(diag.ok == 0)
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,diag.bandClass,strlen(diag.bandClass));
            else
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,diag.status,strlen(diag.status));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_bandClass\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_serviceType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {
        case MODE_GET:
        	getNetParameter(CGAGENT_WWAN_SERVICE_TYPE, requests);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_serviceType\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_rfChannel(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    s_diag diag = {1,"","","","","","","","",""};
    switch(reqinfo->mode) {
        case MODE_GET:
            diag = getDiagnostics();
            if(diag.ok == 0)
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,diag.rfChannel,strlen(diag.rfChannel));
            else
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,diag.status,strlen(diag.status));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rfChannel\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_plmn(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    switch(reqinfo->mode) {
        case MODE_GET:
        	getNetParameter(CGAGENT_WWAN_PLMN, requests);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_plmn\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_csCellIDandLac(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    s_cellInfo cell = {"","","",""};
    char *result;
    result = (char*) calloc (SIZEBUFF,sizeof(char));
    memset(result,0,SIZEBUFF);
    switch(reqinfo->mode) {
        case MODE_GET:
//            cell = getLacAndCellId(CS_REG);
	    strcat(result,cell.cs_cellId);
	    strcat(result,",");
	    strcat(result,cell.cs_lac);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
	    free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_csCellIDandLac\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_psCellIDandLac(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    s_cellInfo cell = {"","","",""};
    char * result;
    result = (char*) calloc (SIZEBUFF,sizeof(char));
    memset(result,0,SIZEBUFF);
    switch(reqinfo->mode) {
        case MODE_GET:
//            cell = getLacAndCellId(PS_REG);
            strcat(result,cell.ps_cellId);
            strcat(result,",");
            strcat(result,cell.ps_lac);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
	    free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_psCellIDandLac\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_pinStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;   
    switch(reqinfo->mode) {
        case MODE_GET:
	    result = getPinState(PIN);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pinStatus\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_pinRetries(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    switch(reqinfo->mode) {
        case MODE_GET:
            result = getPinState(PIN_COUNT);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pinRetries\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_pukRetries(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char * result;
    switch(reqinfo->mode) {
        case MODE_GET:
            result = getPinState(PUK_COUNT);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,result,strlen(result));
            free(result);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pukRetries\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_rxPackets(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
/*
	cg_status_t cg_status;
	cg_net_stats_t stats;
	uint64_t result = 0;

    switch(reqinfo->mode) {

        case MODE_GET:
			cg_status = cg_net_datacounter_get_stats(wwan_device, &stats);
			if (cg_status == CG_STATUS_OK)
			{
				result = 123456789; //stats.rx_packets;
			}
            snmp_set_var_typed_value(requests->requestvb, ASN_APP_U64, (u_char *) &result, sizeof(result));
			break;
*/


    s_dcounter counter;
    counter.rxPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.rxBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
		if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
	    getCounters(wwan_device,&counter);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,counter.rxPackets,strlen(counter.rxPackets));
	    free(counter.rxPackets);
	    free(counter.rxBytes);
            free(counter.txPackets);
	    free(counter.txBytes);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rxPackets\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_rxBytes(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
/*
	cg_status_t cg_status;
	cg_net_stats_t stats;
	uint64_t result = 0;

    switch(reqinfo->mode) {

        case MODE_GET:
			cg_status = cg_net_datacounter_get_stats(wwan_device, &stats);
			if (cg_status == CG_STATUS_OK)
			{
				result = stats.rx_bytes;
			}
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER64, (u_char *) & (result), sizeof(result));
			break;
*/

    s_dcounter counter;
    counter.rxPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.rxBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
			if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
			getCounters(wwan_device,&counter);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,counter.rxBytes,strlen(counter.rxBytes));
            free(counter.rxPackets);
            free(counter.rxBytes);
            free(counter.txPackets);
            free(counter.txBytes);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rxBytes\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_txPackets(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
/*
	cg_status_t cg_status;
	cg_net_stats_t stats;
	uint64_t result = 0;

    switch(reqinfo->mode) {

        case MODE_GET:
			cg_status = cg_net_datacounter_get_stats(wwan_device, &stats);
			if (cg_status == CG_STATUS_OK)
			{
				result = stats.tx_packets;
			}
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER64, (u_char *) & (result), sizeof(result));
			break;
*/

    s_dcounter counter;
    counter.rxPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.rxBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
			getCounters(wwan_device,&counter);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,counter.txPackets,strlen(counter.txPackets));
            free(counter.rxPackets);
            free(counter.rxBytes);
            free(counter.txPackets);
            free(counter.txBytes);
	    break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_txPackets\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_txBytes(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
/*
	cg_status_t cg_status;
	cg_net_stats_t stats;
	uint64_t result = 0;

    switch(reqinfo->mode) {

        case MODE_GET:
			cg_status = cg_net_datacounter_get_stats(wwan_device, &stats);
			if (cg_status == CG_STATUS_OK)
			{
				result = stats.tx_bytes;
			}
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER64, (u_char *) & (result), sizeof(result));
			break;
*/

    s_dcounter counter;
    counter.rxPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.rxBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txPackets = (char *) calloc (SIZEBUFF,sizeof(char));
    counter.txBytes = (char *) calloc (SIZEBUFF,sizeof(char));
    switch(reqinfo->mode) {

        case MODE_GET:
            if (wwan_device == NULL) cg_wwan_get_active_primary_dev( &wwan_device );
			getCounters(wwan_device,&counter);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,counter.txBytes,strlen(counter.txBytes));
            free(counter.rxPackets);
            free(counter.rxBytes);
            free(counter.txPackets);
            free(counter.txBytes);
	    break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_txBytes\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
